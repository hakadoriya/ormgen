// Code generated by ormgen; DO NOT EDIT.
//
// source: {{ $.SourceFile }}
package {{ $.PackageName }}

import (
	"context"
	"fmt"
	"strings"

	{{ $ormcommonPackageImportPath := $.ORMCommonPackageImportPath | basename }}{{ $ormcommonPackageImportPath }} "{{ $.ORMCommonPackageImportPath }}"
	{{ $ormoptPackageImportPath := $.ORMOptPackageImportPath | basename }}{{ $ormoptPackageImportPath }} "{{ $.ORMOptPackageImportPath }}"

	{{ $packageImportPathOriginal := $.PackageImportPath | basename }}{{ $packageImportPath := print $packageImportPathOriginal "_" }}{{ $packageImportPath }} "{{ $.PackageImportPath }}"
)
{{ range $i, $table := $.Tables }}
const Insert{{ $table.StructName }}Query = `INSERT INTO {{ $table.TableName }} ({{- range $i, $column := $table.Columns }}{{ if $i }}, {{ end }}{{ $column.ColumnName }}{{- end }}) VALUES ({{ placeholder $table.Columns 1 }})`

func (s *_ORM) Insert{{ $table.StructName }}(ctx context.Context, queryerContext {{ $ormoptPackageImportPath }}.QueryerContext, {{ $table.TableName }} *{{ $packageImportPath }}.{{ $table.StructName }}) error {
	{{ $ormcommonPackageImportPath }}.LoggerFromContext(ctx).Debug(Insert{{ $table.StructName }}Query)
	_, err := queryerContext.ExecContext(ctx, Insert{{ $table.StructName }}Query, {{ range $i, $column := $table.Columns }}{{ if $i }}, {{ end }}{{ $table.TableName }}.{{ $column.FieldName }}{{- end }})
	if err != nil {
		return fmt.Errorf("queryerContext.ExecContext: %w", s.HandleError(ctx, err))
	}
	return nil
}

const BulkInsert{{ $table.StructName }}QueryPrefix = `INSERT INTO {{ $table.TableName }} ({{- range $i, $column := $table.Columns }}{{ if $i }}, {{ end }}{{ $column.ColumnName }}{{- end }}) VALUES `

func (s *_ORM) BulkInsert{{ $table.StructName }}(ctx context.Context, queryerContext {{ $ormoptPackageImportPath }}.QueryerContext, {{ $table.StructName | lowerFirst }}Slice []*{{ $packageImportPath }}.{{ $table.StructName }}) error {
	if len({{ $table.StructName | lowerFirst }}Slice) == 0 {
		return nil
	}

	// Calculate the number of placeholders per row and the maximum number of rows per query
	const (
		placeholderStartAt = 1
		placeholdersPerRow = {{ len $table.Columns }}
	)

	maxRowsPerQuery := DefaultBulkInsertMaxPlaceholdersPerQuery / placeholdersPerRow
	placeholderIdx := placeholderStartAt
	for i := 0; i < len({{ $table.StructName | lowerFirst }}Slice); i += maxRowsPerQuery {
		end := i + maxRowsPerQuery
		if end > len({{ $table.StructName | lowerFirst }}Slice) {
			end = len({{ $table.StructName | lowerFirst }}Slice)
		}

		chunk := {{ $table.StructName | lowerFirst }}Slice[i:end]
		placeholders := make([]string, len(chunk))
		args := make([]interface{}, 0, len(chunk)*placeholdersPerRow)

		for j := range chunk {
			placeholders[j] += "("
			for i := range placeholdersPerRow {
				if i > 0 {
					placeholders[j] += ", "
				}
				placeholders[j] += DefaultPlaceholderGenerator(placeholderIdx)
				placeholderIdx++
			}
			placeholders[j] += ")"
			args = append(args, {{ range $i, $column := $table.Columns }}{{ if $i }}, {{ end }}chunk[j].{{ $column.FieldName }}{{- end }})
		}

		query := BulkInsert{{ $table.StructName }}QueryPrefix + strings.Join(placeholders, ", ")
		{{ $ormcommonPackageImportPath }}.LoggerFromContext(ctx).Debug(query)

		_, err := queryerContext.ExecContext(ctx, query, args...)
		if err != nil {
			return fmt.Errorf("queryerContext.ExecContext: %w", s.HandleError(ctx, err))
		}
	}

	return nil
}

const Get{{ $table.StructName }}ByPKQuery = `SELECT {{ range $i, $column := $table.Columns }}{{ if $i }}, {{ end }}{{ $column.ColumnName }}{{- end }} FROM {{ $table.TableName }} WHERE {{ placeholderInWhere $table.PrimaryKeys "AND" 1 }}`

func (s *_ORM) Get{{ $table.StructName }}ByPK(ctx context.Context, queryerContext {{ $ormoptPackageImportPath }}.QueryerContext, {{ range $i, $pk := $table.PrimaryKeys }}{{ if $i }}, {{ end }}{{ $pk.ColumnName }} {{ $pk.FieldType }}{{ end }}) (*{{ $packageImportPath }}.{{ $table.StructName }}, error) {
	{{ $ormcommonPackageImportPath }}.LoggerFromContext(ctx).Debug(Get{{ $table.StructName }}ByPKQuery)
	row := queryerContext.QueryRowContext(ctx, Get{{ $table.StructName }}ByPKQuery, {{ range $i, $pk := $table.PrimaryKeys }}{{ if $i }}, {{ end }}{{ $pk.ColumnName }}{{ end }})
	{{ $table.StructName | lowerFirst }} := new({{ $packageImportPath }}.{{ $table.StructName }})
	err := row.Scan({{ range $i, $v := $table.Columns }}{{ if $i }}, {{ end }}&{{ $table.StructName | lowerFirst }}.{{ $v.FieldName }}{{- end }})
	if err != nil {
		return nil, fmt.Errorf("row.Scan: %w", s.HandleError(ctx, err))
	}
	return {{ $table.StructName | lowerFirst }}, nil
}
{{ if or (ne $.Dialect "sqlite3") }}
const Lock{{ $table.StructName }}ByPKQuery = `SELECT {{ range $i, $column := $table.Columns }}{{ if $i }}, {{ end }}{{ $column.ColumnName }}{{- end }} FROM {{ $table.TableName }} WHERE {{ placeholderInWhere $table.PrimaryKeys "AND" 1 }} FOR UPDATE`

func (s *_ORM) Lock{{ $table.StructName }}ByPK(ctx context.Context, queryerContext {{ $ormoptPackageImportPath }}.QueryerContext, {{ range $i, $pk := $table.PrimaryKeys }}{{ if $i }}, {{ end }}{{ $pk.ColumnName }} {{ $pk.FieldType }}{{ end }}) (*{{ $packageImportPath }}.{{ $table.StructName }}, error) {
	{{ $ormcommonPackageImportPath }}.LoggerFromContext(ctx).Debug(Lock{{ $table.StructName }}ByPKQuery)
	row := queryerContext.QueryRowContext(ctx, Lock{{ $table.StructName }}ByPKQuery, {{ range $i, $pk := $table.PrimaryKeys }}{{ if $i }}, {{ end }}{{ $pk.ColumnName }}{{ end }})
	{{ $table.StructName | lowerFirst }} := new({{ $packageImportPath }}.{{ $table.StructName }})
	err := row.Scan({{ range $i, $v := $table.Columns }}{{ if $i }}, {{ end }}&{{ $table.StructName | lowerFirst }}.{{ $v.FieldName }}{{- end }})
	if err != nil {
		return nil, fmt.Errorf("row.Scan: %w", s.HandleError(ctx, err))
	}
	return {{ $table.StructName | lowerFirst }}, nil
}
{{ end -}}
{{ range $i, $hasOneTagsKey := $table.HasOneTagsKeys -}}
{{- /* map access by slice element */ -}}{{- $hasOneColumns := index $table.HasOneTags $hasOneTagsKey }}
const Get{{ $table.StructName }}By{{ $hasOneTagsKey }}Query = `SELECT {{ range $i, $column := $table.Columns }}{{ if $i }}, {{ end }}{{ $column.ColumnName }}{{- end }} FROM {{ $table.TableName }} WHERE {{ placeholderInWhere $hasOneColumns "AND" 1 }}`

func (s *_ORM) Get{{ $table.StructName }}By{{ $hasOneTagsKey }}(ctx context.Context, queryerContext {{ $ormoptPackageImportPath }}.QueryerContext, {{ range $i, $hasOneCol := $hasOneColumns }}{{ if $i }}, {{ end }}{{ $hasOneCol.ColumnName }} {{ $hasOneCol.FieldType }}{{ end }}) (*{{ $packageImportPath }}.{{ $table.StructName }}, error) {
	{{ $ormcommonPackageImportPath }}.LoggerFromContext(ctx).Debug(Get{{ $table.StructName }}By{{ $hasOneTagsKey }}Query)
	row := queryerContext.QueryRowContext(ctx, Get{{ $table.StructName }}By{{ $hasOneTagsKey }}Query, {{ range $i, $hasOneCol := $hasOneColumns }}{{ if $i }}, {{ end }}{{ $hasOneCol.ColumnName }}{{ end }})
	{{ $table.StructName | lowerFirst }} := new({{ $packageImportPath }}.{{ $table.StructName }})
	err := row.Scan({{ range $i, $column := $table.Columns }}{{ if $i }}, {{ end }}&{{ $table.StructName | lowerFirst }}.{{ $column.FieldName }}{{- end }})
	if err != nil {
		return nil, fmt.Errorf("row.Scan: %w", s.HandleError(ctx, err))
	}
	return {{ $table.StructName | lowerFirst }}, nil
}
{{ if or (ne $.Dialect "sqlite3") }}
const Lock{{ $table.StructName }}By{{ $hasOneTagsKey }}Query = `SELECT {{ range $i, $column := $table.Columns }}{{ if $i }}, {{ end }}{{ $column.ColumnName }}{{- end }} FROM {{ $table.TableName }} WHERE {{ placeholderInWhere $hasOneColumns "AND" 1 }} FOR UPDATE`

func (s *_ORM) Lock{{ $table.StructName }}By{{ $hasOneTagsKey }}(ctx context.Context, queryerContext {{ $ormoptPackageImportPath }}.QueryerContext, {{ range $i, $hasOneCol := $hasOneColumns }}{{ if $i }}, {{ end }}{{ $hasOneCol.ColumnName }} {{ $hasOneCol.FieldType }}{{ end }}, opts ...{{ $ormoptPackageImportPath }}.ResultOption) (*{{ $packageImportPath }}.{{ $table.StructName }}, error) {
	config := new({{ $ormoptPackageImportPath }}.QueryConfig)
	{{ $ormoptPackageImportPath }}.WithPlaceholderGenerator(DefaultPlaceholderGenerator).ApplyResultOption(config)
	for _, o := range opts {
		o.ApplyResultOption(config)
	}
	query, args := config.ToSQL(Lock{{ $table.StructName }}By{{ $hasOneTagsKey }}Query, {{ $currentIndex := len $hasOneColumns }}{{ add $currentIndex 1 }})
	{{ $ormcommonPackageImportPath }}.LoggerFromContext(ctx).Debug(query)
	row := queryerContext.QueryRowContext(ctx, query, append([]interface{}{{print `{`}}{{ range $i, $hasOneCol := $hasOneColumns }}{{ if $i }}, {{ end }}{{ $hasOneCol.ColumnName }}{{ end }}{{print `}`}}, args...)...)
	{{ $table.StructName | lowerFirst }} := new({{ $packageImportPath }}.{{ $table.StructName }})
	err := row.Scan({{ range $i, $column := $table.Columns }}{{ if $i }}, {{ end }}&{{ $table.StructName | lowerFirst }}.{{ $column.FieldName }}{{- end }})
	if err != nil {
		return nil, fmt.Errorf("row.Scan: %w", s.HandleError(ctx, err))
	}
	return {{ $table.StructName | lowerFirst }}, nil
}
{{ end -}}
{{ end -}}
{{ range $i, $hasManyTagsKey := $table.HasManyTagsKeys -}}
{{- /* map access by slice element */ -}}{{- $hasManyColumns := index $table.HasManyTags $hasManyTagsKey }}
const List{{ $table.StructName }}By{{ $hasManyTagsKey }}Query = `SELECT {{ range $i, $column := $table.Columns }}{{ if $i }}, {{ end }}{{ $column.ColumnName }}{{- end }} FROM {{ $table.TableName }} WHERE ({{ placeholderInWhere $hasManyColumns "AND" 1 }})`

func (s *_ORM) List{{ $table.StructName }}By{{ $hasManyTagsKey }}(ctx context.Context, queryerContext {{ $ormoptPackageImportPath }}.QueryerContext, {{ range $i, $hasManyCol := $hasManyColumns }}{{ if $i }}, {{ end }}{{ $hasManyCol.ColumnName }} {{ $hasManyCol.FieldType }}{{ end }}, opts ...{{ $ormoptPackageImportPath }}.ResultOption) ({{ $packageImportPath }}.{{ $table.StructName }}{{ $.SliceTypeSuffix }}, error) {
	config := new({{ $ormoptPackageImportPath }}.QueryConfig)
	{{ $ormoptPackageImportPath }}.WithPlaceholderGenerator(DefaultPlaceholderGenerator).ApplyResultOption(config)
	for _, o := range opts {
		o.ApplyResultOption(config)
	}
	query, args := config.ToSQL(List{{ $table.StructName }}By{{ $hasManyTagsKey }}Query, {{ $currentIndex := len $hasManyColumns }}{{ add $currentIndex 1 }})
	{{ $ormcommonPackageImportPath }}.LoggerFromContext(ctx).Debug(query)
	rows, err := queryerContext.QueryContext(ctx, query, append([]interface{}{{print `{`}}{{ range $i, $hasManyCol := $hasManyColumns }}{{ if $i }}, {{ end }}{{ $hasManyCol.ColumnName }}{{ end }}{{print `}`}}, args...)...)
	if err != nil {
		return nil, fmt.Errorf("queryerContext.QueryContext: %w", s.HandleError(ctx, err))
	}
	var {{ $table.StructName | lowerFirst }}Slice {{ $packageImportPath }}.{{ $table.StructName }}{{ $.SliceTypeSuffix }}
	for rows.Next() {
		{{ $table.TableName }} := new({{ $packageImportPath }}.{{ $table.StructName }})
		err := rows.Scan({{ range $i, $v := $table.Columns }}{{ if $i }}, {{ end }}&{{ $table.TableName }}.{{ $v.FieldName }}{{- end }})
		if err != nil {
			return nil, fmt.Errorf("rows.Scan: %w", s.HandleError(ctx, err))
		}
		{{ $table.StructName | lowerFirst }}Slice = append({{ $table.StructName | lowerFirst }}Slice, {{ $table.TableName }})
	}
	if err := rows.Close(); err != nil {
		return nil, fmt.Errorf("rows.Close: %w", s.HandleError(ctx, err))
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows.Err: %w", s.HandleError(ctx, err))
	}
	return {{ $table.StructName | lowerFirst }}Slice, nil
}
{{ if or (ne $.Dialect "sqlite3") }}
const Lock{{ $table.StructName }}By{{ $hasManyTagsKey }}Query = `SELECT {{ range $i, $column := $table.Columns }}{{ if $i }}, {{ end }}{{ $column.ColumnName }}{{- end }} FROM {{ $table.TableName }} WHERE ({{ placeholderInWhere $hasManyColumns "AND" 1 }}) FOR UPDATE`

func (s *_ORM) Lock{{ $table.StructName }}By{{ $hasManyTagsKey }}(ctx context.Context, queryerContext {{ $ormoptPackageImportPath }}.QueryerContext, {{ range $i, $hasManyCol := $hasManyColumns }}{{ if $i }}, {{ end }}{{ $hasManyCol.ColumnName }} {{ $hasManyCol.FieldType }}{{ end }}, opts ...{{ $ormoptPackageImportPath }}.ResultOption) ({{ $packageImportPath }}.{{ $table.StructName }}{{ $.SliceTypeSuffix }}, error) {
	config := new({{ $ormoptPackageImportPath }}.QueryConfig)
	{{ $ormoptPackageImportPath }}.WithPlaceholderGenerator(DefaultPlaceholderGenerator).ApplyResultOption(config)
	for _, o := range opts {
		o.ApplyResultOption(config)
	}
	query, args := config.ToSQL(Lock{{ $table.StructName }}By{{ $hasManyTagsKey }}Query, {{ $currentIndex := len $hasManyColumns }}{{ add $currentIndex 1 }})
	{{ $ormcommonPackageImportPath }}.LoggerFromContext(ctx).Debug(query)
	rows, err := queryerContext.QueryContext(ctx, query, append([]interface{}{{print `{`}}{{ range $i, $hasManyCol := $hasManyColumns }}{{ if $i }}, {{ end }}{{ $hasManyCol.ColumnName }}{{ end }}{{print `}`}}, args...)...)
	if err != nil {
		return nil, fmt.Errorf("queryerContext.QueryContext: %w", s.HandleError(ctx, err))
	}
	var {{ $table.StructName | lowerFirst }}Slice {{ $packageImportPath }}.{{ $table.StructName }}{{ $.SliceTypeSuffix }}
	for rows.Next() {
		{{ $table.TableName }} := new({{ $packageImportPath }}.{{ $table.StructName }})
		err := rows.Scan({{ range $i, $v := $table.Columns }}{{ if $i }}, {{ end }}&{{ $table.TableName }}.{{ $v.FieldName }}{{- end }})
		if err != nil {
			return nil, fmt.Errorf("rows.Scan: %w", s.HandleError(ctx, err))
		}
		{{ $table.StructName | lowerFirst }}Slice = append({{ $table.StructName | lowerFirst }}Slice, {{ $table.TableName }})
	}
	if err := rows.Close(); err != nil {
		return nil, fmt.Errorf("rows.Close: %w", s.HandleError(ctx, err))
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows.Err: %w", s.HandleError(ctx, err))
	}
	return {{ $table.StructName | lowerFirst }}Slice, nil
}
{{ end -}}
{{ end }}
const List{{ $table.StructName }}Query = `SELECT {{ range $i, $column := $table.Columns }}{{ if $i }}, {{ end }}{{ $column.ColumnName }}{{- end }} FROM {{ $table.TableName }}`

func (s *_ORM) List{{ $table.StructName }}(ctx context.Context, queryerContext {{ $ormoptPackageImportPath }}.QueryerContext, opts ...{{ $ormoptPackageImportPath }}.QueryOption) ({{ $packageImportPath }}.{{ $table.StructName }}{{ $.SliceTypeSuffix }}, error) {
	config := new({{ $ormoptPackageImportPath }}.QueryConfig)
	{{ $ormoptPackageImportPath }}.WithPlaceholderGenerator(DefaultPlaceholderGenerator).ApplyResultOption(config)
	for _, o := range opts {
		o.ApplyQueryOption(config)
	}
	query, args := config.ToSQL(List{{ $table.StructName }}Query, 1)
	{{ $ormcommonPackageImportPath }}.LoggerFromContext(ctx).Debug(query)
	rows, err := queryerContext.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("queryerContext.QueryContext: %w", s.HandleError(ctx, err))
	}
	var {{ $table.StructName | lowerFirst }}Slice {{ $packageImportPath }}.{{ $table.StructName }}{{ $.SliceTypeSuffix }}
	for rows.Next() {
		{{ $table.TableName }} := new({{ $packageImportPath }}.{{ $table.StructName }})
		err := rows.Scan({{ range $i, $v := $table.Columns }}{{ if $i }}, {{ end }}&{{ $table.TableName }}.{{ $v.FieldName }}{{- end }})
		if err != nil {
			return nil, fmt.Errorf("rows.Scan: %w", s.HandleError(ctx, err))
		}
		{{ $table.StructName | lowerFirst }}Slice = append({{ $table.StructName | lowerFirst }}Slice, {{ $table.TableName }})
	}
	if err := rows.Close(); err != nil {
		return nil, fmt.Errorf("rows.Close: %w", s.HandleError(ctx, err))
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows.Err: %w", s.HandleError(ctx, err))
	}
	return {{ $table.StructName | lowerFirst }}Slice, nil
}
{{ if or (ne $.Dialect "sqlite3") }}
const Lock{{ $table.StructName }}Query = `SELECT {{ range $i, $column := $table.Columns }}{{ if $i }}, {{ end }}{{ $column.ColumnName }}{{- end }} FROM {{ $table.TableName }}`

func (s *_ORM) Lock{{ $table.StructName }}(ctx context.Context, queryerContext {{ $ormoptPackageImportPath }}.QueryerContext, opts ...{{ $ormoptPackageImportPath }}.QueryOption) ({{ $packageImportPath }}.{{ $table.StructName }}{{ $.SliceTypeSuffix }}, error) {
	config := new({{ $ormoptPackageImportPath }}.QueryConfig)
	{{ $ormoptPackageImportPath }}.WithPlaceholderGenerator(DefaultPlaceholderGenerator).ApplyResultOption(config)
	for _, o := range opts {
		o.ApplyQueryOption(config)
	}
	query, args := config.ToSQL(Lock{{ $table.StructName }}Query, 1)
	{{ $ormcommonPackageImportPath }}.LoggerFromContext(ctx).Debug(query)
	rows, err := queryerContext.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("queryerContext.QueryContext: %w", s.HandleError(ctx, err))
	}
	var {{ $table.StructName | lowerFirst }}Slice {{ $packageImportPath }}.{{ $table.StructName }}{{ $.SliceTypeSuffix }}
	for rows.Next() {
		{{ $table.TableName }} := new({{ $packageImportPath }}.{{ $table.StructName }})
		err := rows.Scan({{ range $i, $v := $table.Columns }}{{ if $i }}, {{ end }}&{{ $table.TableName }}.{{ $v.FieldName }}{{- end }})
		if err != nil {
			return nil, fmt.Errorf("rows.Scan: %w", s.HandleError(ctx, err))
		}
		{{ $table.StructName | lowerFirst }}Slice = append({{ $table.StructName | lowerFirst }}Slice, {{ $table.TableName }})
	}
	if err := rows.Close(); err != nil {
		return nil, fmt.Errorf("rows.Close: %w", s.HandleError(ctx, err))
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows.Err: %w", s.HandleError(ctx, err))
	}
	return {{ $table.StructName | lowerFirst }}Slice, nil
}
{{ end }}
const Update{{ $table.StructName }}Query = `UPDATE {{ $table.TableName }} SET ({{ range $i, $column := $table.NotPrimaryKeys }}{{ if $i }}, {{ end }}{{ $column.ColumnName }}{{- end }}) = ({{ placeholder $table.NotPrimaryKeys 1 }}) WHERE {{ $currentIndex := len $table.NotPrimaryKeys }}{{ $nextIndex := add $currentIndex 1 }}{{ placeholderInWhere .PrimaryKeys "AND" $nextIndex }}`

func (s *_ORM) Update{{ $table.StructName }}(ctx context.Context, queryerContext {{ $ormoptPackageImportPath }}.QueryerContext, {{ $table.TableName }} *{{ $packageImportPath }}.{{ $table.StructName }}) error {
	{{ $ormcommonPackageImportPath }}.LoggerFromContext(ctx).Debug(Update{{ $table.StructName }}Query)
	_, err := queryerContext.ExecContext(ctx, Update{{ $table.StructName }}Query, {{ range $i, $column := $table.NotPrimaryKeys }}{{ if $i }}, {{ end }}{{ $table.TableName }}.{{ $column.FieldName }}{{- end }}, {{ range $i, $v := $table.PrimaryKeys }}{{ if $i }}, {{ end }}{{ $table.TableName }}.{{ $v.FieldName }}{{ end }})
	if err != nil {
		return fmt.Errorf("queryerContext.ExecContext: %w", s.HandleError(ctx, err))
	}
	return nil
}

const Delete{{ $table.StructName }}ByPKQuery = `DELETE FROM {{ $table.TableName }} WHERE {{ placeholderInWhere $table.PrimaryKeys "AND" 1 }}`

func (s *_ORM) Delete{{ $table.StructName }}ByPK(ctx context.Context, queryerContext {{ $ormoptPackageImportPath }}.QueryerContext, {{ range $i, $pk := $table.PrimaryKeys }}{{ if $i }}, {{ end }}{{ $pk.ColumnName }} {{ $pk.FieldType }}{{ end }}) error {
	{{ $ormcommonPackageImportPath }}.LoggerFromContext(ctx).Debug(Delete{{ $table.StructName }}ByPKQuery)
	_, err := queryerContext.ExecContext(ctx, Delete{{ $table.StructName }}ByPKQuery, {{ range $i, $pk := $table.PrimaryKeys }}{{ if $i }}, {{ end }}{{ $pk.ColumnName }}{{ end }})
	if err != nil {
		return fmt.Errorf("queryerContext.ExecContext: %w", s.HandleError(ctx, err))
	}
	return nil
}
{{ range $i, $hasOneTagsKey := $table.HasOneTagsKeys -}}
{{- /* map access by slice element */ -}}{{- $hasOneColumns := index $table.HasOneTags $hasOneTagsKey }}
const Delete{{ $table.StructName }}By{{ $hasOneTagsKey }}Query = `DELETE FROM {{ $table.TableName }} WHERE {{ placeholderInWhere $hasOneColumns "AND" 1 }}`

func (s *_ORM) Delete{{ $table.StructName }}By{{ $hasOneTagsKey }}(ctx context.Context, queryerContext {{ $ormoptPackageImportPath }}.QueryerContext, {{ range $i, $hasOneCol := $hasOneColumns }}{{ if $i }}, {{ end }}{{ $hasOneCol.ColumnName }} {{ $hasOneCol.FieldType }}{{ end }}) error {
	{{ $ormcommonPackageImportPath }}.LoggerFromContext(ctx).Debug(Delete{{ $table.StructName }}By{{ $hasOneTagsKey }}Query)
	_, err := queryerContext.ExecContext(ctx, Delete{{ $table.StructName }}By{{ $hasOneTagsKey }}Query, {{ range $i, $hasOneCol := $hasOneColumns }}{{ if $i }}, {{ end }}{{ $hasOneCol.ColumnName }}{{ end }})
	if err != nil {
		return fmt.Errorf("queryerContext.ExecContext: %w", s.HandleError(ctx, err))
	}
	return nil
}
{{ end -}}
{{ range $i, $hasManyTagsKey := $table.HasManyTagsKeys -}}
{{- /* map access by slice element */ -}}{{- $hasManyColumns := index $table.HasManyTags $hasManyTagsKey }}
const Delete{{ $table.StructName }}By{{ $hasManyTagsKey }}Query = `DELETE FROM {{ $table.TableName }} WHERE ({{ placeholderInWhere $hasManyColumns "AND" 1 }})`

func (s *_ORM) Delete{{ $table.StructName }}By{{ $hasManyTagsKey }}(ctx context.Context, queryerContext {{ $ormoptPackageImportPath }}.QueryerContext, {{ range $i, $hasManyCol := $hasManyColumns }}{{ if $i }}, {{ end }}{{ $hasManyCol.ColumnName }} {{ $hasManyCol.FieldType }}{{ end }}) error {
	{{ $ormcommonPackageImportPath }}.LoggerFromContext(ctx).Debug(Delete{{ $table.StructName }}By{{ $hasManyTagsKey }}Query)
	_, err := queryerContext.ExecContext(ctx, Delete{{ $table.StructName }}By{{ $hasManyTagsKey }}Query, {{ range $i, $hasManyCol := $hasManyColumns }}{{ if $i }}, {{ end }}{{ $hasManyCol.ColumnName }}{{ end }})
	if err != nil {
		return fmt.Errorf("queryerContext.ExecContext: %w", s.HandleError(ctx, err))
	}
	return nil
}
{{ end -}}
{{ end -}}
