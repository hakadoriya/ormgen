// Code generated by ormgen; DO NOT EDIT.
//
// source: {{ $.SourceFile }}
package {{ $.PackageName }}

import (
	"context"
	"strconv"

	{{ $ormcommonPackageImportPath := $.ORMCommonPackageImportPath | basename }}{{ $ormcommonPackageImportPath }} "{{ $.ORMCommonPackageImportPath }}"
	{{ $ormoptPackageImportPath := $.ORMOptPackageImportPath | basename }}{{ $ormoptPackageImportPath }} "{{ $.ORMOptPackageImportPath }}"
	{{ $packageImportPathOriginal := $.PackageImportPath | basename }}{{ $packageImportPath := print $packageImportPathOriginal "_" }}{{ $packageImportPath }} "{{ $.PackageImportPath }}"
)

var (
	DefaultBulkInsertMaxPlaceholdersPerQuery = 2000
	DefaultPlaceholderGenerator              = placeholderGenerator
)

var strconvItoa = strconv.Itoa

type ORM interface {
	{{- range $i, $table := $.Tables }}
	// Insert{{ $table.StructName }} inserts a new {{ $table.StructName }} into the database.
	Insert{{ $table.StructName }}(ctx context.Context, queryerContext {{ $ormcommonPackageImportPath }}.QueryerContext, {{ $table.TableName }} *{{ $packageImportPath }}.{{ $table.StructName }}) error
	// BulkInsert{{ $table.StructName }} inserts multiple {{ $table.StructName }} into the database.
	BulkInsert{{ $table.StructName }}(ctx context.Context, queryerContext {{ $ormcommonPackageImportPath }}.QueryerContext, {{ $table.StructName | lowerFirst }}Slice []*{{ $packageImportPath }}.{{ $table.StructName }}) error
	// Get{{ $table.StructName }}ByPK gets a {{ $table.StructName }} by its primary keys.
	Get{{ $table.StructName }}ByPK(ctx context.Context, queryerContext {{ $ormcommonPackageImportPath }}.QueryerContext, {{ range $i, $pk := $table.PrimaryKeys }}{{ if $i }}, {{ end }}{{ $pk.ColumnName }} {{ $pk.FieldType }}{{ end }}) (*{{ $packageImportPath }}.{{ $table.StructName }}, error)
	{{- if or (ne $.Dialect "sqlite3") }}
	// Select{{ $table.StructName }}ForUpdateByPK locks a {{ $table.StructName }} by its primary keys.
	Select{{ $table.StructName }}ForUpdateByPK(ctx context.Context, queryerContext {{ $ormcommonPackageImportPath }}.QueryerContext, {{ range $i, $pk := $table.PrimaryKeys }}{{ if $i }}, {{ end }}{{ $pk.ColumnName }} {{ $pk.FieldType }}{{ end }}) (*{{ $packageImportPath }}.{{ $table.StructName }}, error)
	{{- end -}}
	{{- range $i, $hasOneTagsKey := $table.HasOneTagsKeys -}}
	{{- /* map access by slice element */ -}}{{- $hasOneColumns := index $table.HasOneTags $hasOneTagsKey }}
	// Get{{ $table.StructName }}By{{ $hasOneTagsKey }} gets a {{ $table.StructName }} by its {{ $hasOneTagsKey }}.
	Get{{ $table.StructName }}By{{ $hasOneTagsKey }}(ctx context.Context, queryerContext {{ $ormcommonPackageImportPath }}.QueryerContext, {{ range $i, $hasOneCol := $hasOneColumns }}{{ if $i }}, {{ end }}{{ $hasOneCol.ColumnName }} {{ $hasOneCol.FieldType }}{{ end }}) (*{{ $packageImportPath }}.{{ $table.StructName }}, error)
	{{- if or (ne $.Dialect "sqlite3") }}
	// Select{{ $table.StructName }}ForUpdateBy{{ $hasOneTagsKey }} locks a {{ $table.StructName }} by its {{ $hasOneTagsKey }}.
	Select{{ $table.StructName }}ForUpdateBy{{ $hasOneTagsKey }}(ctx context.Context, queryerContext {{ $ormcommonPackageImportPath }}.QueryerContext, {{ range $i, $hasOneCol := $hasOneColumns }}{{ if $i }}, {{ end }}{{ $hasOneCol.ColumnName }} {{ $hasOneCol.FieldType }}{{ end }}, opts ...{{ $ormoptPackageImportPath }}.ResultOption) (*{{ $packageImportPath }}.{{ $table.StructName }}, error)
	{{- end -}}
	{{- end }}
	{{- range $i, $hasManyTagsKey := $table.HasManyTagsKeys -}}
	{{- /* map access by slice element */ -}}{{- $hasManyColumns := index $table.HasManyTags $hasManyTagsKey }}
	// List{{ $table.StructName }}By{{ $hasManyTagsKey }} returns a slice of {{ $table.StructName }} by its {{ $hasManyTagsKey }}.
	List{{ $table.StructName }}By{{ $hasManyTagsKey }}(ctx context.Context, queryerContext {{ $ormcommonPackageImportPath }}.QueryerContext, {{ range $i, $hasManyCol := $hasManyColumns }}{{ if $i }}, {{ end }}{{ $hasManyCol.ColumnName }} {{ $hasManyCol.FieldType }}{{ end }}, opts ...{{ $ormoptPackageImportPath }}.ResultOption) ({{ $packageImportPath }}.{{ $table.StructName }}{{ $.SliceTypeSuffix }}, error)
	{{- if or (ne $.Dialect "sqlite3") }}
	// Select{{ $table.StructName }}ForUpdateBy{{ $hasManyTagsKey }} locks a {{ $table.StructName }} by its {{ $hasManyTagsKey }}.
	Select{{ $table.StructName }}ForUpdateBy{{ $hasManyTagsKey }}(ctx context.Context, queryerContext {{ $ormcommonPackageImportPath }}.QueryerContext, {{ range $i, $hasManyCol := $hasManyColumns }}{{ if $i }}, {{ end }}{{ $hasManyCol.ColumnName }} {{ $hasManyCol.FieldType }}{{ end }}, opts ...{{ $ormoptPackageImportPath }}.ResultOption) ({{ $packageImportPath }}.{{ $table.StructName }}{{ $.SliceTypeSuffix }}, error)
	{{- end -}}
	{{- end }}
	// GetOne{{ $table.StructName }} returns a {{ $table.StructName }}.
	// If no rows are found, it returns sql.ErrNoRows.
	// If multiple rows are found, it returns {{ $ormcommonPackageImportPath }}.ErrNotUnique.
	GetOne{{ $table.StructName }}(ctx context.Context, queryerContext {{ $ormcommonPackageImportPath }}.QueryerContext, opts ...{{ $ormoptPackageImportPath }}.QueryOption) (*{{ $packageImportPath }}.{{ $table.StructName }}, error)
	// List{{ $table.StructName }} returns a slice of {{ $table.StructName }}.
	List{{ $table.StructName }}(ctx context.Context, queryerContext {{ $ormcommonPackageImportPath }}.QueryerContext, opts ...{{ $ormoptPackageImportPath }}.QueryOption) ({{ $packageImportPath }}.{{ $table.StructName }}{{ $.SliceTypeSuffix }}, error)
	{{- if or (ne $.Dialect "sqlite3") }}
	// Select{{ $table.StructName }}ForUpdate locks a {{ $table.StructName }}.
	Select{{ $table.StructName }}ForUpdate(ctx context.Context, queryerContext {{ $ormcommonPackageImportPath }}.QueryerContext, opts ...{{ $ormoptPackageImportPath }}.QueryOption) ({{ $packageImportPath }}.{{ $table.StructName }}{{ $.SliceTypeSuffix }}, error)
	{{- end }}
	// Update{{ $table.StructName }} updates a {{ $table.StructName }}.
	Update{{ $table.StructName }}(ctx context.Context, queryerContext {{ $ormcommonPackageImportPath }}.QueryerContext, {{ $table.TableName }} *{{ $packageImportPath }}.{{ $table.StructName }}) error
	// Delete{{ $table.StructName }}ByPK deletes a {{ $table.StructName }} by its primary keys.
	Delete{{ $table.StructName }}ByPK(ctx context.Context, queryerContext {{ $ormcommonPackageImportPath }}.QueryerContext, {{ range $i, $pk := $table.PrimaryKeys }}{{ if $i }}, {{ end }}{{ $pk.ColumnName }} {{ $pk.FieldType }}{{ end }}) error
	{{- range $i, $hasOneTagsKey := $table.HasOneTagsKeys -}}
	{{- /* map access by slice element */ -}}{{- $hasOneColumns := index $table.HasOneTags $hasOneTagsKey }}
	// Delete{{ $table.StructName }}By{{ $hasOneTagsKey }} deletes a {{ $table.StructName }} by its {{ $hasOneTagsKey }}.
	Delete{{ $table.StructName }}By{{ $hasOneTagsKey }}(ctx context.Context, queryerContext {{ $ormcommonPackageImportPath }}.QueryerContext, {{ range $i, $hasOneCol := $hasOneColumns }}{{ if $i }}, {{ end }}{{ $hasOneCol.ColumnName }} {{ $hasOneCol.FieldType }}{{ end }}) error
	{{- end }}
	{{- range $i, $hasManyTagsKey := $table.HasManyTagsKeys -}}
	{{- /* map access by slice element */ -}}{{- $hasManyColumns := index $table.HasManyTags $hasManyTagsKey }}
	// Delete{{ $table.StructName }}By{{ $hasManyTagsKey }} deletes a {{ $table.StructName }} by its {{ $hasManyTagsKey }}.
	Delete{{ $table.StructName }}By{{ $hasManyTagsKey }}(ctx context.Context, queryerContext {{ $ormcommonPackageImportPath }}.QueryerContext, {{ range $i, $hasManyCol := $hasManyColumns }}{{ if $i }}, {{ end }}{{ $hasManyCol.ColumnName }} {{ $hasManyCol.FieldType }}{{ end }}) error
	{{- end }}
	{{- end }}
}

func NewORM(opts ...ORMOption) ORM {
	o := new(_ORM)
	for _, opt := range opts {
		opt.apply(o)
	}
	return o
}

type ORMOption interface {
	apply(o *_ORM)
}

func WithORMOptionHandleErrorFunc(handleErrorFunc func(ctx context.Context, err error) error) ORMOption {
	return &ormOptionHandleErrorFunc{handleErrorFunc: handleErrorFunc}
}

type ormOptionHandleErrorFunc struct {
	handleErrorFunc func(ctx context.Context, err error) error
}

func (o *ormOptionHandleErrorFunc) apply(s *_ORM) {
	s.HandleErrorFunc = o.handleErrorFunc
}

type _ORM struct {
	HandleErrorFunc func(ctx context.Context, err error) error
}

func (o *_ORM) HandleError(ctx context.Context, err error) error {
	if o.HandleErrorFunc != nil {
		return o.HandleErrorFunc(ctx, err)
	}
	return err
}

// placeholderGenerator is {{ $.Dialect }} dialect placeholder generator
{{- if or (eq $.Dialect "postgres") (eq $.Dialect "cockroach") }}
func placeholderGenerator(i int) string {
	return "$" + strconvItoa(i)
}
{{- else if or (eq $.Dialect "mysql") (eq $.Dialect "sqlite3") (eq $.Dialect "spanner") }}
func placeholderGenerator(_ int) string {
	return "?"
}
{{- else }}
func placeholderGenerator(_ int) string {
	panic("unsupported dialect: `{{ $.Dialect }}`")
}
{{ end }}
